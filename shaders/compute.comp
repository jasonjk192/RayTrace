#version 430

#define MAT_DIFFUSE 0
#define MAT_METAL 1
#define MAT_DIELECTRIC 2
#define MAT_LIGHT 3

#define PI 3.1415926538
#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439  // 1.0/SQRT_OF_2PI
#define INV_PI 0.31830988618379067153776752674503

const float inf = 99999.f;
const int samples_per_pixel = 50;
const int max_depth = 8;
const uint k = 1103515245U; 

struct Camera
{
  vec3 origin;
  vec3 horizontal;
  vec3 vertical;
  vec3 lower_left_corner;
};

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

uniform Camera cam;
uniform int Time;

////////////////////// Random number generation //////////////////////

float gSeed = 0.0;

uint baseHash(uvec2 p)
{
    p = 1103515245U * ((p >> 1U) ^ (p.yx));
    uint h32 = 1103515245U * ((p.x) ^ (p.y>>3U));
    return h32 ^ (h32 >> 16);
}

float hash1(inout float seed) {
    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1,seed += 0.1)));
    return float(n) / float(0xffffffffU);
}

vec2 hash2(inout float seed) {
    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1,seed += 0.1)));
    uvec2 rz = uvec2(n, n * 48271U);
    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);
}

vec3 hash3(inout float seed)
{
    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));
    uvec3 rz = uvec3(n, n * 16807U, n * 48271U);
    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);
}

uint lowbias32(uint x)
{
    x ^= x >> 16;
    x *= 0x7feb352dU;
    x ^= x >> 15;
    x *= 0x846ca68bU;
    x ^= x >> 16;
    return x;
}

float lowbiashash(uint seed) { return float(lowbias32(seed)) / float(0xffffffffU); }

float random(vec2 st)
{
    //return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    uvec2 ST = uvec2(st);
    return lowbiashash( ST.x + lowbias32(ST.y));
}

float random(vec2 st, float amin, float amax)
{
    return amin + (amax-amin)*random(st);
}

vec3 random_vec3(vec2 st)
{
    return vec3(random(st), random(st * 0.33), random(st * 0.54));
}

vec3 random_vec3(vec2 st, float amin, float amax)
{
    //return vec3(random(st, amin, amax), random(st * 0.13, amin, amax), random(st * 0.14, amin, amax));
    return (amax - amin) * random_vec3(st) + vec3(amin);
}

vec3 random_in_unit_sphere(vec2 st)
{ 
    return normalize(random_vec3(st, -1, 1));
}

vec3 random_in_unit_sphere(inout float seed)
{
    vec3 h = hash3(seed) * vec3(2.0, 6.28318530718, 1.0) - vec3(1.0, 0.0, 0.0);
    float phi = h.y;
    float r = pow(h.z, 1.0/3.0);
	return r * vec3(sqrt(1.0 - h.x * h.x) * vec2(sin(phi), cos(phi)), h.x);
}

vec3 random_in_hemisphere(vec3 normal, vec2 st)
{
    vec3 in_unit_sphere = random_in_unit_sphere(st);
    if (dot(in_unit_sphere, normal) > 0.0)
        return in_unit_sphere;
    else
        return -in_unit_sphere;
}

vec3 random_in_hemisphere(vec3 normal, inout float seed)
{
    vec3 in_unit_sphere = random_in_unit_sphere(seed);
    if (dot(in_unit_sphere, normal) > 0.0)
        return in_unit_sphere;
    else
        return -in_unit_sphere;
}

vec3 random_to_sphere(float radius, float distance_squared, inout float seed)
{
    float r1 = hash1(seed);
    float r2 = hash1(seed);
    float z = 1 + r2 * (sqrt(1 - radius * radius / distance_squared) - 1);

    float phi = 2 * PI * r1;
    float x = cos(phi) * sqrt(1 - z * z);
    float y = sin(phi) * sqrt(1 - z * z);

    return vec3(x, y, z);
}

vec3 random_cosine_direction(inout float seed)
{
    float r1 = hash1(seed);
    float r2 = hash1(seed);
    float z = sqrt(1-r2);

    float phi = 2*PI*r1;
    float x = cos(phi)*sqrt(r2);
    float y = sin(phi)*sqrt(r2);

    return vec3(x, y, z);
}

//////////////////////////////////////////////////////////////////

///////////// Ray /////////////

struct Ray
{
  vec3 origin;
  vec3 direction;
  float time;
};

vec3 at(Ray r, float dist) { return r.direction * dist + r.origin; }

///////////////////////////////

////////// Material ////////////

struct Material
{
    int type;
    vec3 albedo;
    float fuzz;
    float ir;
};

///////////////////////////////

///////// Hit Record //////////

struct HitRecord
{
  vec3 p;
  vec3 normal;
  float t;
  bool front_face;
  Material material;
};

void set_face_normal(Ray r, vec3 outward_normal, inout HitRecord rec)
{
  rec.front_face = dot(r.direction, outward_normal) < 0;
  rec.normal = (rec.front_face) ? outward_normal : -1 * outward_normal;
}

///////////////////////////////

/////// Scatter Record ////////

struct ScatterRecord {
    Ray specular_ray;
    bool is_specular;
    vec3 attenuation;
    float pdf;
};

///////////////////////////////

//////////// ONB //////////////

vec3[3] build_onb_from_w(vec3 n)
{
    vec3[3] axis;
    axis[2] = normalize(n);
    vec3 a = (abs(axis[2].x) > 0.9) ? vec3(0,1,0) : vec3(1,0,0);
    axis[1] = normalize(cross(axis[2], a));
    axis[0] = cross(axis[2], axis[1]);
    return axis;
}

vec3 onb_local(vec3[3] uvw, vec3 a)
{
    return a.x * uvw[0] + a.y * uvw[1] + a.z * uvw[2];
}

///////////////////////////////

/////// Scene Elements ////////

struct Sphere
{
    vec3 center;
    float radius;
};

vec3 random_point_on_sphere(vec3 center, float radius, vec3 o, inout float seed)
{
    vec3 direction = center - o;
    float distance_squared = dot(direction, direction);
    vec3[3] uvw = build_onb_from_w(direction);
    return onb_local(uvw, random_to_sphere(radius, distance_squared, seed));
}

bool hit_sphere(Sphere s, Ray r, float t_min, float t_max, inout HitRecord rec)
{
	vec3 oc = r.origin - s.center;
    float a = dot(r.direction, r.direction);
    float half_b = dot(oc, r.direction);
    float c = dot(oc, oc) - s.radius*s.radius;

    float discriminant = half_b*half_b - a*c;
    if (discriminant < 0) return false;
    float sqrtd = sqrt(discriminant);

    float root = (-half_b - sqrtd) / a;
    if (root < t_min || t_max < root)
    {
        root = (-half_b + sqrtd) / a;
        if (root < t_min || t_max < root)
            return false;
    }

    rec.t = root;
    rec.p = at(r,rec.t);
    set_face_normal(r, (rec.p - s.center) / s.radius, rec);

    return true;
}

///////////////////////////////

/////////// Scene /////////////

bool hit_world(Ray r, float t_min, float t_max, inout HitRecord rec)
{
    Sphere s1 = Sphere(vec3(0.0,0.0,-1.0), 0.5);
    Sphere s2 = Sphere(vec3(0.0,-100.5,-1.0), 100);
    Sphere s3 = Sphere(vec3(-1.0, 0.0, -1.0), 0.5);
    Sphere s4 = Sphere(vec3(1.0, 0.0, -1.0), 0.5);
    Sphere s5 = Sphere(vec3(0.0, 1.0, -1.0), 0.1);

    bool hasHit = false;
    rec.t = t_max;

    if(hit_sphere(s1, r, t_min, rec.t, rec))
    {
        hasHit = true;
        rec.material = Material(MAT_DIFFUSE, vec3(0.9,0.1,0.4), 1.0, 0.0);
    }
    if(hit_sphere(s2, r, t_min, rec.t, rec))
    {
        hasHit = true;
        rec.material = Material(MAT_METAL, vec3(0.8,0.8,0), 1.0, 0.0);
    }
    if(hit_sphere(s3, r, t_min, rec.t, rec))
    {
        hasHit = true;
        rec.material = Material(MAT_METAL, vec3(0.7,0.4,0.9), 0.5, 0.0);
    }
    if(hit_sphere(s4, r, t_min, rec.t, rec))
    {
        hasHit = true;
        rec.material = Material(MAT_DIELECTRIC, vec3(1.0), 0.0, 1.5);
    }

    /*if(hit_sphere(s5, r, t_min, rec.t, rec))
    {
        hasHit = true;
        rec.material = Material(MAT_LIGHT, vec3(50.0), 0.0, 1.5);
    }*/

    return hasHit;
}

///////////////////////////////

//////// Ray Tracing //////////

vec3 get_sky(vec3 dir)
{
    //return vec3(0);
    float t = 0.5*(dir.y + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
}

float reflectance(float cosine, float ref_idx)
{
    float r0 = (1-ref_idx) / (1+ref_idx);
    r0 = r0*r0;
    return r0 + (1-r0)*pow((1 - cosine),5);
}

float ray_material_scattering_pdf(Ray r, HitRecord rec, Ray scattered)
{
    float cosine = dot(rec.normal, normalize(scattered.direction));
            return cosine < 0 ? 0 : cosine/PI;
    return 0;
}

vec3 ray_material_emit(Ray r, HitRecord rec)
{
    if(rec.material.type == 3)
        return rec.material.albedo;
    return vec3(0);
}

bool ray_material_scatter(Ray r, HitRecord rec, vec2 st, inout float seed, out ScatterRecord srec)
{
    if(rec.material.type == MAT_DIFFUSE)
    {
        vec3[3] uvw = build_onb_from_w(rec.normal);
        vec3 local_direction = onb_local(uvw, random_cosine_direction(seed));
        srec.is_specular = false;
        srec.attenuation = rec.material.albedo;
        return true;
    }

    if(rec.material.type == MAT_METAL)
    {
        vec3 reflection = reflect(normalize(r.direction), rec.normal);
        srec.specular_ray = Ray(rec.p, normalize(reflection + rec.material.fuzz * random_in_unit_sphere(gSeed)), r.time);
        srec.attenuation = rec.material.albedo;
        srec.is_specular = true;
        return true;
    }

    if(rec.material.type == MAT_DIELECTRIC)
    {
        float refraction_ratio = rec.front_face ? (1.0/rec.material.ir) : rec.material.ir;
        vec3 unit_direction = normalize(r.direction);
        float cos_theta = min(dot(-unit_direction, rec.normal), 1.0);
        float sin_theta = sqrt(1.0 - cos_theta*cos_theta);

        bool cannot_refract = refraction_ratio * sin_theta > 1.0;
        vec3 direction;
        if (cannot_refract || reflectance(cos_theta, refraction_ratio) > hash1(gSeed))
            direction = reflect(unit_direction, rec.normal);
        else
            direction = refract(unit_direction, rec.normal, refraction_ratio);

        srec.specular_ray = Ray(rec.p, normalize(direction), r.time);
        srec.is_specular = true;
        srec.attenuation = vec3(1.0);
        return true;
    }

    if(rec.material.type == MAT_LIGHT)
    {
        srec.attenuation = rec.material.albedo;
        srec.is_specular = false;
        return false;
    }

    return false;
}

vec3 ray_color(Ray r, vec2 st, inout float seed)
{
    vec3 color = vec3(1.0);

    HitRecord rec;
    for(int i = 0; i < max_depth; ++i)
    {
        if(hit_world(r, 0.001, inf, rec))
        {
            vec3 emit_color = ray_material_emit(r, rec);
            ScatterRecord srec;

            if(ray_material_scatter(r, rec, st, seed, srec))
            {
                if(srec.is_specular)
                {
                    color *= srec.attenuation;
                    r = srec.specular_ray;
                }
                else
                {
                    vec3 scatter_direction;
                    vec3[3] uvw_for_lambert = build_onb_from_w(rec.normal);

                    // Generate scatter ray from either diffuse material (cosine pdf) or dielectric glass material (hittable pdf)
                    // Workaround for mixture pdf, doesn't support light source sampling for now
                    if(hash1(seed) > 0.5)
                    {
                        vec3 direction = vec3(1, 0, -1) - rec.p;
                        float distance_squared = dot(direction, direction);
                        vec3[3] uvw = build_onb_from_w(direction);
                        scatter_direction = onb_local(uvw, random_to_sphere(0.5, distance_squared, seed));
                    }
                    else
                    {
                        scatter_direction = onb_local(uvw_for_lambert, random_cosine_direction(seed));
                    }
                    Ray scattered = Ray(rec.p, scatter_direction, r.time);

                    // Then find out the pdf contribution of both pdfs and average them out
                    vec3 direction = vec3(1, 0, -1) - scatter_direction;
                    float radius = 0.5;
                    float cos_theta_max = sqrt(1 - radius * radius / dot(direction, direction));
                    float solid_angle = 2 * PI * (1 - cos_theta_max);
                    float pdf_value_1 = 1/solid_angle;
                    
                    float cosine = dot(normalize(scatter_direction), uvw_for_lambert[2]);
                    float pdf_value_2 = (cosine <= 0) ? 0 : cosine / PI;

                    float pdf = (pdf_value_1 + pdf_value_2) * 0.5;

                    color *= srec.attenuation * ray_material_scattering_pdf(r, rec, scattered) / pdf;
                    color += emit_color;
                    r = scattered;
                }
            }
            else return color + emit_color;
        }
        else return color * get_sky(normalize(r.direction));
    }
    return color;
}

///////////////////////////////

void main()
{
	vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);

	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	ivec2 img_size = imageSize(img_output);

    gSeed = float(baseHash(floatBitsToUint(pixel_coords))) / float(0xffffffffU) + Time;

    vec2 st = vec2(float(pixel_coords.x) / (float(img_size.x) - 1), float(pixel_coords.y) / (float(img_size.y) - 1));

	Ray r;
	r.origin = cam.origin;

    for(int s=0; s<samples_per_pixel; s++)
    {
        vec2 n = hash2(gSeed);
        float u = float(pixel_coords.x + n.x) / (float(img_size.x) - 1);
	    float v = float(pixel_coords.y + n.y) / (float(img_size.y) - 1);

        r.direction = cam.lower_left_corner + u * cam.horizontal + v * cam.vertical - cam.origin;
        pixel.rgb += ray_color(r, st, gSeed);
    }
    pixel.r = isnan(pixel.r)? 0 : pixel.r;
    pixel.g = isnan(pixel.g)? 0 : pixel.g;
    pixel.b = isnan(pixel.b)? 0 : pixel.b;

    pixel.rgb = sqrt(pixel.rgb/samples_per_pixel);

	imageStore(img_output, pixel_coords, pixel);
}