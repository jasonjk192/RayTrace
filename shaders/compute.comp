#version 430

#define MAT_DIFFUSE 0
#define MAT_METAL 1
#define MAT_DIELECTRIC 2
#define MAT_LIGHT 3

#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439  // 1.0/SQRT_OF_2PI
#define INV_PI 0.31830988618379067153776752674503

const float inf = 99999.f;
const int samples_per_pixel = 30;
const int max_depth = 10;
const uint k = 1103515245U; 

struct Camera
{
  vec3 origin;
  vec3 horizontal;
  vec3 vertical;
  vec3 lower_left_corner;
};

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

uniform Camera cam;
uniform int Time;

////////////////////// Random number generation //////////////////////

float gSeed = 0.0;

uint baseHash(uvec2 p)
{
    p = 1103515245U * ((p >> 1U) ^ (p.yx));
    uint h32 = 1103515245U * ((p.x) ^ (p.y>>3U));
    return h32 ^ (h32 >> 16);
}

float hash1(inout float seed) {
    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1,seed += 0.1)));
    return float(n) / float(0xffffffffU);
}

vec2 hash2(inout float seed) {
    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1,seed += 0.1)));
    uvec2 rz = uvec2(n, n * 48271U);
    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);
}

vec3 hash3(inout float seed)
{
    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));
    uvec3 rz = uvec3(n, n * 16807U, n * 48271U);
    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);
}

uint lowbias32(uint x)
{
    x ^= x >> 16;
    x *= 0x7feb352dU;
    x ^= x >> 15;
    x *= 0x846ca68bU;
    x ^= x >> 16;
    return x;
}

float lowbiashash(uint seed) { return float(lowbias32(seed)) / float(0xffffffffU); }

float random(vec2 st)
{
    //return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    uvec2 ST = uvec2(st);
    return lowbiashash( ST.x + lowbias32(ST.y));
}

float random(vec2 st, float amin, float amax)
{
    return amin + (amax-amin)*random(st);
}

vec3 random_vec3(vec2 st)
{
    return vec3(random(st), random(st * 0.33), random(st * 0.54));
}

vec3 random_vec3(vec2 st, float amin, float amax)
{
    //return vec3(random(st, amin, amax), random(st * 0.13, amin, amax), random(st * 0.14, amin, amax));
    return (amax - amin) * random_vec3(st) + vec3(amin);
}

vec3 random_in_unit_sphere(vec2 st)
{ 
    return normalize(random_vec3(st, -1, 1));
}

vec3 random_in_unit_sphere(inout float seed)
{
    vec3 h = hash3(seed) * vec3(2.0, 6.28318530718, 1.0) - vec3(1.0, 0.0, 0.0);
    float phi = h.y;
    float r = pow(h.z, 1.0/3.0);
	return r * vec3(sqrt(1.0 - h.x * h.x) * vec2(sin(phi), cos(phi)), h.x);
}

vec3 random_in_hemisphere(vec3 normal, vec2 st)
{
    vec3 in_unit_sphere = random_in_unit_sphere(st);
    if (dot(in_unit_sphere, normal) > 0.0)
        return in_unit_sphere;
    else
        return -in_unit_sphere;
}

vec3 random_in_hemisphere(vec3 normal, inout float seed)
{
    vec3 in_unit_sphere = random_in_unit_sphere(seed);
    if (dot(in_unit_sphere, normal) > 0.0)
        return in_unit_sphere;
    else
        return -in_unit_sphere;
}

//////////////////////////////////////////////////////////////////

///////////// Ray /////////////

struct Ray
{
  vec3 origin;
  vec3 direction;
  float time;
};

vec3 at(Ray r, float dist) { return r.direction * dist + r.origin; }

///////////////////////////////

////////// Material ////////////

struct Material
{
    int type;
    vec3 albedo;
    float fuzz;
    float ir;
};

///////////////////////////////

///////// Hit Record //////////

struct HitRecord
{
  vec3 p;
  vec3 normal;
  float t;
  bool front_face;
  Material material;
};

void set_face_normal(Ray r, vec3 outward_normal, inout HitRecord rec)
{
  rec.front_face = dot(r.direction, outward_normal) < 0;
  rec.normal = (rec.front_face) ? outward_normal : -1 * outward_normal;
}

///////////////////////////////

/////// Scene Elements ////////

struct Sphere
{
  vec3 center;
  float radius;
};

bool hit_sphere(Sphere s, Ray r, float t_min, float t_max, inout HitRecord rec)
{
	vec3 oc = r.origin - s.center;
    float a = dot(r.direction, r.direction);
    float half_b = dot(oc, r.direction);
    float c = dot(oc, oc) - s.radius*s.radius;

    float discriminant = half_b*half_b - a*c;
    if (discriminant < 0) return false;
    float sqrtd = sqrt(discriminant);

    float root = (-half_b - sqrtd) / a;
    if (root < t_min || t_max < root)
    {
        root = (-half_b + sqrtd) / a;
        if (root < t_min || t_max < root)
            return false;
    }

    rec.t = root;
    rec.p = at(r,rec.t);
    set_face_normal(r, (rec.p - s.center) / s.radius, rec);

    return true;
}

///////////////////////////////

/////////// Scene /////////////

bool hit_world(Ray r, float t_min, float t_max, inout HitRecord rec)
{
    Sphere s1 = Sphere(vec3(0.0,0.0,-1.0), 0.5);
    Sphere s2 = Sphere(vec3(0.0,-100.5,-1.0), 100);
    Sphere s3 = Sphere(vec3(-1.0, 0.0, -1.0), 0.5);
    Sphere s4 = Sphere(vec3(1.0, 0.0, -1.0), 0.5);
    Sphere s5 = Sphere(vec3(0.0, 1.0, -1.0), 0.1);

    bool hasHit = false;
    rec.t = t_max;

    if(hit_sphere(s1, r, t_min, rec.t, rec))
    {
        hasHit = true;
        rec.material = Material(MAT_DIFFUSE, vec3(1,0,0), 1.0, 0.0);
    }
    if(hit_sphere(s2, r, t_min, rec.t, rec))
    {
        hasHit = true;
        rec.material = Material(MAT_METAL, vec3(0,1,0), 1.0, 0.0);
    }
    if(hit_sphere(s3, r, t_min, rec.t, rec))
    {
        hasHit = true;
        rec.material = Material(MAT_METAL, vec3(0.5,0.6,0.5), 0.5, 0.0);
    }
    if(hit_sphere(s4, r, t_min, rec.t, rec))
    {
        hasHit = true;
        rec.material = Material(MAT_DIELECTRIC, vec3(1.0), 0.0, 1.5);
    }

    if(hit_sphere(s5, r, t_min, rec.t, rec))
    {
        hasHit = true;
        rec.material = Material(MAT_LIGHT, vec3(50.0), 0.0, 1.5);
    }

    return hasHit;
}

///////////////////////////////

//////// Ray Tracing //////////

vec3 get_sky(vec3 dir)
{
    return vec3(0.1);
    float t = 0.5*(dir.y + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
}

vec3 ray_material_emit(Ray r, HitRecord rec)
{
    if(rec.material.type == 3)
        return rec.material.albedo;
    return vec3(0);
}

float reflectance(float cosine, float ref_idx)
{
    float r0 = (1-ref_idx) / (1+ref_idx);
    r0 = r0*r0;
    return r0 + (1-r0)*pow((1 - cosine),5);
}

bool ray_material_scatter(Ray r, HitRecord rec, vec2 st, out vec3 attenuation, out Ray outRay)
{
    if(rec.material.type == MAT_DIFFUSE)
    {
        vec3 target = rec.p + random_in_hemisphere(rec.normal, gSeed);
        outRay.origin = rec.p;
        outRay.direction = target - rec.p;
        attenuation = rec.material.albedo;
        return true;
    }
    if(rec.material.type == MAT_METAL)
    {
        vec3 reflection = reflect(normalize(r.direction), rec.normal);
        outRay.origin = rec.p;
        outRay.direction = reflection + rec.material.fuzz * random_in_unit_sphere(gSeed);
        attenuation = rec.material.albedo;
        return dot(outRay.direction, rec.normal) > 0;
    }
    if(rec.material.type == MAT_DIELECTRIC)
    {
        attenuation = vec3(1.0);
        float refraction_ratio = rec.front_face ? (1.0/rec.material.ir) : rec.material.ir;
        vec3 unit_direction = normalize(r.direction);
        float cos_theta = min(dot(-unit_direction, rec.normal), 1.0);
        float sin_theta = sqrt(1.0 - cos_theta*cos_theta);

        bool cannot_refract = refraction_ratio * sin_theta > 1.0;
        vec3 direction;
        if (cannot_refract || reflectance(cos_theta, refraction_ratio) > hash1(gSeed))
            direction = reflect(unit_direction, rec.normal);
        else
            direction = refract(unit_direction, rec.normal, refraction_ratio);

        outRay.origin = rec.p;
        outRay.direction = direction;
        return true;
    }
    if(rec.material.type == MAT_LIGHT)
    {
        attenuation = rec.material.albedo;
        return true;
    }
    return false;
}

vec3 ray_color(Ray r, vec2 st)
{
    vec3 color = vec3(1.0);

    HitRecord rec;
    for(int i = 0; i < max_depth; ++i)
    {
        if(hit_world(r, 0.001, inf, rec))
        {
            Ray nr;
            vec3 atten;
            if(ray_material_scatter(r, rec, st, atten, nr))
            {
                color *= atten;
                color += ray_material_emit(r, rec);
                r = nr;
            }
            else return vec3(0);
        }
        else return color * get_sky(normalize(r.direction));
    }
    return color;
}

///////////////////////////////

void main()
{
	vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);

	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	ivec2 img_size = imageSize(img_output);

    gSeed = float(baseHash(floatBitsToUint(pixel_coords))) / float(0xffffffffU) + Time;

    vec2 st = vec2(float(pixel_coords.x) / (float(img_size.x) - 1), float(pixel_coords.y) / (float(img_size.y) - 1));

	Ray r;
	r.origin = cam.origin;

    for(int s=0; s<samples_per_pixel; s++)
    {
        vec2 n = hash2(gSeed);
        float u = float(pixel_coords.x + n.x) / (float(img_size.x) - 1);
	    float v = float(pixel_coords.y + n.y) / (float(img_size.y) - 1);

        r.direction = cam.lower_left_corner + u * cam.horizontal + v * cam.vertical - cam.origin;
        pixel.rgb += ray_color(r, st);
    }
    pixel.rgb = sqrt(pixel.rgb/samples_per_pixel);

	imageStore(img_output, pixel_coords, pixel);
}